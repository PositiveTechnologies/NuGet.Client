<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" DefaultTargets="Test" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), 'README.md'))\build\common.props" />

  <!-- Configuration/global properties -->
  <PropertyGroup>
    <CommonMSBuildProperties>
      Configuration=$(Configuration);
      ReleaseLabel=$(ReleaseLabel);
      BuildNumber=$(BuildNumber);
      BuildRTM=$(BuildRTM);
    </CommonMSBuildProperties>
  </PropertyGroup>

  <UsingTask TaskName="GetTimeStamp" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup><TimeStamp ParameterType="System.Int64" Output="true" /></ParameterGroup>
    <Task>
      <Using Namespace="System.Diagnostics" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[ TimeStamp = System.Diagnostics.Stopwatch.GetTimestamp(); ]]>
      </Code>
    </Task>
  </UsingTask>

  <UsingTask TaskName="GetElapsedTimeSpan" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.v4.0.dll">
    <ParameterGroup>
      <ElapsedTimeSpan ParameterType="System.String" Output="true" />
      <StartTicks ParameterType="System.Int64" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Diagnostics" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[

        // We can get the current timestamp and then calculate the elapsed ticks. To improve
        // accuracy of the benchmark, you could expose another task parameter to allow passing in the
        // current ticks, so that the overhead of calling this task isn't included in the elapsed
        // calculation.
        var currentTicks = Stopwatch.GetTimestamp();
        var elapsedTicks = currentTicks - StartTicks;

        // This code is taken from a combination of the static constructor and private GetElapsedDateTimeTicks method in Stopwatch.
        if (Stopwatch.IsHighResolution)
        {
            var tickFrequency = 10000000.0d / (double) Stopwatch.Frequency;
            elapsedTicks = (long) ((double) elapsedTicks * tickFrequency);
        }

        // Now we can get a more human-readable elapsed time. Unfortunately we can't return the TimeSpan
        // as a parameter, as it doesn't implement IConvertible. So we'll just convert it to a string.
        // If you really want to do more with the resulting TimeSpan, you could always refactor this to return the ticks,
        // and create the TimeSpan using property functions as in the DateTime example (the Elapsed property).
        ElapsedTimeSpan = TimeSpan.FromTicks(elapsedTicks).ToString();

        ]]>
      </Code>
    </Task>
  </UsingTask>


  <Target Name="BenchmarkStart">
    <GetTimeStamp>
      <Output PropertyName="StartTimeStamp" TaskParameter="TimeStamp" />
    </GetTimeStamp>

    <Message Text="Starting timestamp: $(StartTimeStamp)"/>
  </Target>
  <Target Name="BenchmarkEnd">
    <GetElapsedTimeSpan StartTicks="$(StartTimeStamp)">
        <Output PropertyName="EndTimeSpan" TaskParameter="ElapsedTimeSpan" />
      </GetElapsedTimeSpan>

      <Message Text="Elapsed time: $(EndTimeSpan)"/>
  </Target>

  <!--
    ============================================================
    Get XPLAT projects
    ============================================================
  -->
  <Target Name="GetXPLATProjects">
      <MsBuild
      Projects="@(AllSolutionProjects)"
      Targets="GetXPLATProject">
      <Output
          TaskParameter="TargetOutputs"
          ItemName="XPLATProjects" />
    </MsBuild>
  </Target>

  <!--
    ============================================================
    Run core functional tests (non-VS specific)
    ============================================================
  -->
  <Target Name="CoreFuncTests" DependsOnTargets="BuildVS;Pack">
    <!-- Test inputs -->
    <PropertyGroup>
      <TestProjectPaths>@(CoreFuncTestProjects)</TestProjectPaths>
      <TestResultsFileName>CoreFuncTests</TestResultsFileName>
    </PropertyGroup>

    <!-- Run tests as a batch -->
    <MSBuild
        Projects="$(MSBuildThisFileFullPath)"
        Targets="RunTestsOnProjects"
        Properties="$(CommonMSBuildProperties);
                    TestResultsFileName=$(TestResultsFileName);
                    TestProjectPaths=$(TestProjectPaths)">
      <Output TaskParameter="TargetOutputs"
              ItemName="TestAssemblyPath" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    Run core unit tests (non-VS specific)
    ============================================================
  -->
  <Target Name="CoreUnitTests">
    <!-- Test inputs -->
    <PropertyGroup>
      <TestProjectPaths>@(CoreUnitTestProjects)</TestProjectPaths>
      <TestResultsFileName>CoreUnitTests</TestResultsFileName>
    </PropertyGroup>

    <!-- Run tests as a batch -->
    <MSBuild
        Projects="$(MSBuildThisFileFullPath)"
        Targets="RunTestsOnProjects"
        Properties="$(CommonMSBuildProperties);
                    TestResultsFileName=$(TestResultsFileName);
                    TestProjectPaths=$(TestProjectPaths)">
      <Output TaskParameter="TargetOutputs"
              ItemName="TestAssemblyPath" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    Run unit tests
    ============================================================
  -->
  <Target Name="UnitTestsVS">
    <!-- Test inputs -->
    <PropertyGroup>
      <TestProjectPaths>@(VSUnitTestProjects)</TestProjectPaths>
      <TestResultsFileName>UnitTestsVS</TestResultsFileName>
    </PropertyGroup>

    <!-- Run tests as a batch -->
    <MSBuild
        Projects="$(MSBuildThisFileFullPath)"
        Targets="RunTestsOnProjects"
        Properties="$(CommonMSBuildProperties);
                    TestResultsFileName=$(TestResultsFileName);
                    TestProjectPaths=$(TestProjectPaths)">
      <Output TaskParameter="TargetOutputs"
              ItemName="TestAssemblyPath" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    Run apex tests
    ============================================================
  -->
  <Target Name="ApexTestsStandalone">

    <!-- Test inputs -->
    <PropertyGroup>
      <TestProjectPaths>$(RepositoryRootDirectory)test\NuGet.Tests.Apex\NuGet.Tests.Apex\NuGet.Tests.Apex.csproj</TestProjectPaths>
      <TestResultsFileName>ApexTestsVS15</TestResultsFileName>
    </PropertyGroup>

    <!-- Run tests as a batch -->
    <MSBuild
        Projects="$(MSBuildThisFileFullPath)"
        Targets="RunTestsOnProjects"
        Properties="$(CommonMSBuildProperties);
                    TestResultsFileName=$(TestResultsFileName);
                    TestProjectPaths=$(TestProjectPaths);
                    Verbosity=-verbose">
      <Output TaskParameter="TargetOutputs"
              ItemName="TestAssemblyPath" />
    </MSBuild>
  </Target>

  <!--
    ============================================================
    Build, Pack, Core Tests, Unit tests for VS
    ============================================================
  -->
  <Target Name="RunVS"  DependsOnTargets="BuildVS;Pack;CoreUnitTests;UnitTestsVS">
  <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Running NuGet Build for VS $(VisualStudioVersion)" Importance="high" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Build 
    ============================================================
  -->
  <Target Name="BuildVS"  Condition=" '$(IsXPlat)' != 'true' " >
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Building for VS $(VisualStudioVersion)" Importance="high" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

    <!--
    ============================================================
    Build for XPLAT 
    ============================================================
  -->
  <Target Name="BuildXPLAT" DependsOnTargets="GetXPLATProjects">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Building XPLAT" Importance="high" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Build no VSIX
    ============================================================
  -->
  <Target Name="BuildNoVSIX" AfterTargets="BuildVS" Condition=" '$(IsXPlat)' != 'true' ">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Building for VS $(VisualStudioVersion)" Importance="high" />

    <MSBuild Projects="@(SolutionProjectsWithoutVSIX)"
             Targets="Build"
             Properties="$(CommonMSBuildProperties);
                         VisualStudioVersion=$(VisualStudioVersion);" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Build XPLAT
    ============================================================
  -->
  <Target Name="BuildXPLATProjects" AfterTargets="BuildXPLAT">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Building XPLAT" Importance="high" />

    <MSBuild Projects="@(XPLATProjects)"
             Targets="Build"
             Properties="$(CommonMSBuildProperties);
                         VisualStudioVersion=$(VisualStudioVersion);" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Build the VSIX
    This target always needs to be below BuildNoVSIX so that
    BuildVS runs the NoVSIX targets before this one.
    ============================================================
  -->
  <Target Name="BuildVSIX" AfterTargets= "BuildVS" Condition=" '$(IsXPlat)' != 'true' AND '$(BuildRTM)' != 'true'">
   <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Building the VSIX for VS $(VisualStudioVersion)" Importance="high" />

    <MSBuild Projects="$(VSIXProject)"
             Targets="Build"
             Properties="$(CommonMSBuildProperties);
                         BuildProjectReferences=false;
                         IsVsixBuild=true;
                         VisualStudioVersion=$(VisualStudioVersion);" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Clean all
    ============================================================
  -->
  <Target Name="Clean">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Cleaning" Importance="high" />

    <!-- Clean -->
    <MSBuild BuildInParallel="true"
             Projects="@(SolutionProjects)"
             Targets="Clean"
             Properties="$(CommonMSBuildProperties);
                         VisualStudioVersion=$(VisualStudioVersion);" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Pack
    ============================================================
  -->
  <Target Name="Pack">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Packing for Visual Studio $(VisualStudioVersion)" Importance="high" />

    <MSBuild BuildInParallel="false"
             Projects="@(SolutionProjects)"
             Targets="PackProjects"
             Properties="$(CommonMSBuildProperties);
                         VisualStudioVersion=$(VisualStudioVersion);" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Pack for XPLAT
    ============================================================
  -->
  <Target Name="PackXPLAT" DependsOnTargets="GetXPLATProjects">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Packing for XPLAT" Importance="high" />

    <MSBuild BuildInParallel="false"
             Projects="@(XPLATProjects)"
             Targets="PackProjects"
             Properties="$(CommonMSBuildProperties);
                         VisualStudioVersion=$(VisualStudioVersion);" />
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Restore all projects for the current platform.
    ============================================================
  -->
  <Target Name="Restore">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Restoring for Visual Studio $(VisualStudioVersion)" Importance="high" />

    <!-- Convert list of projects to a property -->
    <PropertyGroup>
      <ProjectListValue>@(SolutionProjects)</ProjectListValue>
    </PropertyGroup>

    <MSBuild
      Projects="restorehelper.targets"
      Targets="Restore"
      Properties="RestoreGraphProjectInput=$(ProjectListValue);
                  $(CommonMSBuildProperties);
                  VisualStudioVersion=$(VisualStudioVersion)">
    </MSBuild>
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Restore for VS
    ============================================================
  -->
  <Target Name="RestoreVS">
    <CallTarget Targets="BenchmarkStart"/>  
    <MSBuild
      Projects="$(MSBuildThisFileFullPath)"
      Targets="Restore"
      Properties="$(CommonMSBuildProperties);
                  VisualStudioVersion=$(VisualStudioVersion)">
    </MSBuild>
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Restore for XPLAT
    ============================================================
  -->
  <Target Name="RestoreXPLAT" DependsOnTargets="GetXPLATProjects">
  <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Restoring for XPLAT" Importance="high" />
    
    <PropertyGroup>
      <ProjectListValue>@(XPLATProjects)</ProjectListValue>
    </PropertyGroup>

    <MSBuild
      Projects="restorehelper.targets"
      Targets="Restore"
      Properties="RestoreGraphProjectInput=$(ProjectListValue);
                  $(CommonMSBuildProperties);
                  VisualStudioVersion=$(VisualStudioVersion)">
    </MSBuild>
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    Restore Apex 
    ============================================================
  -->
  <Target Name="RestoreApex">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Restoring Apex projects" Importance="high" />

    <PropertyGroup>
      <ProjectListValue>@(ApexProjects)</ProjectListValue>
    </PropertyGroup>

    <MSBuild
      Projects="restorehelper.targets"
      Targets="Restore"
      Properties="RestoreGraphProjectInput=$(ProjectListValue);
                  $(CommonMSBuildProperties);
                  VisualStudioVersion=$(VisualStudioVersion)">
    </MSBuild>
    <CallTarget Targets="BenchmarkEnd"/>
  </Target>

  <!--
    ============================================================
    RunTestsOnProjects
    Finds all test assemblies and allows Xunit to run them as 
    efficiently as the xunit.runner.json settings allow.
    ============================================================
  -->
  <Target Name="RunTestsOnProjects">
    <CallTarget Targets="BenchmarkStart"/>  
    <Message Text="Running $(TestResultsFileName)" Importance="high" />

    <ItemGroup>
      <TestProjectToSearch Include="$(TestProjectPaths)" />
    </ItemGroup>

    <MSBuild
            Projects="@(TestProjectToSearch)"
            Targets="GetTestAssemblies"
            Properties="$(CommonMSBuildProperties);
                         VisualStudioVersion=$(VisualStudioVersion);"
            Condition=" '$(TestProjectPaths)' != '' ">
      <Output TaskParameter="TargetOutputs"
              ItemName="TestAssemblyPath" />
    </MSBuild>

    <PropertyGroup>
      <TestResultsDirectory>$(BuildCommonDirectory)TestResults</TestResultsDirectory>
    </PropertyGroup>

    <!-- Ensure the test results dir exists -->
    <MakeDir Directories="$(TestResultsDirectory)" />

    <PropertyGroup>
      <!-- Sort assemblies -->
      <DesktopInputTestAssemblies>@(TestAssemblyPath->WithMetadataValue("IsDesktop", "true"))</DesktopInputTestAssemblies>
      <DesktopInputTestAssembliesSpaced>$(DesktopInputTestAssemblies.Replace(';', ' '))</DesktopInputTestAssembliesSpaced>
      <CoreInputTestAssemblies>@(TestAssemblyPath->WithMetadataValue("IsCore", "true"))</CoreInputTestAssemblies>
      <CoreInputTestAssembliesSpaced>$(CoreInputTestAssemblies.Replace(';', ' '))</CoreInputTestAssembliesSpaced>
      
      <TestResultOutputFormat Condition="'$(TestResultOutputFormat)' == ''">xml</TestResultOutputFormat>
      <!-- Build exe commands -->
      <TestResultsXunit Condition=" '$(TestResultsFileName)' != '' ">$(TestResultsDirectory)\$(TestResultsFileName)-xunit.$(TestResultOutputFormat)</TestResultsXunit>
      <TestResultsVsts Condition=" '$(TestResultsFileName)' != '' ">$(TestResultsDirectory)\$(TestResultsFileName)-vsts.$(TestResultOutputFormat)</TestResultsVsts>
      <VsTestLogger>--TestAdapterPath:$(XunitXmlLoggerDirectory) --logger:xunit;LogFileName=$(TestResultsFileName)-vsts.$(TestResultOutputFormat)</VsTestLogger>
      <VSTestCommand>$(DotnetExePath) vstest $(CoreInputTestAssembliesSpaced) $(VsTestLogger)</VSTestCommand>
      <DesktopTestCommand>$(XunitConsoleExePath) $(DesktopInputTestAssembliesSpaced)</DesktopTestCommand>
      <DesktopTestCommand Condition=" '$(TestResultsXunit)' != '' ">$(DesktopTestCommand) -$(TestResultOutputFormat) $(TestResultsXunit) $(Verbosity)</DesktopTestCommand>
    </PropertyGroup>
<Message Text="Starting DesktopTest...$([System.DateTime]::Now)"/>
    <!-- Desktop -->
    <Exec Command="$(DesktopTestCommand)"
          ContinueOnError="true"
          Condition=" '$(DesktopInputTestAssemblies)' != '' AND '$(SkipDesktopTests)' != 'true' ">
      <Output TaskParameter="ExitCode" PropertyName="DesktopTestErrorCode"/>
    </Exec>
<Message Text="Done with DesktopTest... $([System.DateTime]::Now)"/>
<Message Text="Starting VSTest... $([System.DateTime]::Now)"/>
    <!-- VSTest/NETCore -->
    <Exec Command="$(VSTestCommand)"
          ContinueOnError="true"
          Condition=" '$(CoreInputTestAssemblies)' != '' AND '$(SkipCoreTests)' != 'true' ">
      <Output TaskParameter="ExitCode" PropertyName="VSTestErrorCode"/>
    </Exec>
<Message Text="Done with VSTest..."/>
    <Error Text="Desktop $(TestResultsFileName) tests failed! Results: $(TestResultsXunit)" Condition=" '$(DesktopTestErrorCode)' != '0' AND '$(DesktopTestErrorCode)' != '' " />
    <Error Text="NETCore $(TestResultsFileName) tests failed! Results: $(TestResultsVsts)" Condition=" '$(VSTestErrorCode)' != '0' AND '$(VSTestErrorCode)' != '' " />

    <Message Text="Desktop $(TestResultsFileName) tests passed! Results: $(TestResultsXunit)" Condition=" '$(DesktopTestErrorCode)' == '0' " Importance="High" />
    <Message Text="NETCore $(TestResultsFileName) tests passed! Results: $(TestResultsVsts)" Condition=" '$(VSTestErrorCode)' == '0' " Importance="High" />
  <CallTarget Targets="BenchmarkEnd"/>
  </Target>
</Project>